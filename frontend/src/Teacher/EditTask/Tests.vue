<script setup lang="ts">
/**
 * Component for test management
 *  - shows list of loaded tests
 *  - allow to modify them and automatically sync changes to tests.yml file
 */

import { ref, watch, reactive } from 'vue';
import { FileEntry } from '../../utilities/SvelteStoreTypes';
import {
  useReadableSvelteStore,
  useWritableSvelteStore
} from '../../utilities/useSvelteStoreInVue';
import Editor from '../../components/Editor.vue';
import SyncLoader from './SyncLoader.vue';
import yaml from 'js-yaml';
import {
  currentOpenedFile as currentOpenedFileSvelte,
  fs,
  cwd as cwdSvelte,
  openedFiles as openedFilesSvelte
} from '../../fs.js';

const cwd = useReadableSvelteStore<FileEntry[]>(cwdSvelte);
const openedFiles = useWritableSvelteStore<Record<string, FileEntry>>(openedFilesSvelte);
const currentOpenedFile = useWritableSvelteStore<string>(currentOpenedFileSvelte);

//indicates whether the tests have been loaded
const loaded = ref<boolean>(false);

interface Test {
  /** autogenerated name in format 'test0' */
  name: string;

  /** user defined name of test */
  title?: string;

  /** arguments passed to the tested program */
  args?: string;

  /** input/output files */
  files?: Record<string, string>;

  /** expected exit code */
  exit_code?: number;
}

let tests = reactive<Record<string, Test>>({});

//used in form, name for input/output file to be created
const new_test_io_file = reactive<Record<string, string>>({});

/**
 * Returns empty test with given name.
 * Used both to load old tests and create new ones
 *
 * @param name name in format `test0`
 */
function create(name: string): Test {
  return {
    name: name,
    files: reactive<Record<string, string>>({})
  };
}

/**
 * Creates new test, with index last_test + 1
 */
function add_test() {
  const name = `test${Object.keys(tests).length}`;
  tests[name] = create(name);
}

/**
 * Removes test of given name and all associated input/output files
 * @param name tame of test to delete
 */
async function delete_test(name: string): Promise<void> {
  const filesToDelete = tests[name]['files'];

  delete tests[name];

  for (const path of Object.values(filesToDelete)) {
    await fs.remove(path);
  }

  currentOpenedFile.value = null;
}

/**
 * Creates a new IO file and attaches it to the test
 * @param name test name
 * @param shown_name name of file showed to user (e.g. file1)
 * @param file_name name of file in FS (e.g. test0.file_in.file1)
 */
async function add_file(name: string, shown_name: string, file_name: string): Promise<void> {
  const path = `${name}.${file_name}`;
  await fs.createFile(path);
  await fs.open(path, { hide_tab: true });
  tests[name]['files'][shown_name] = '/' + path;
}

/**
 * Removes one IO file
 * @param name test to which the file belongs
 * @param file_name name of IO file
 */
async function remove_file(name: string, file_name: string): Promise<void> {
  const path = tests[name]['files'][file_name];
  delete tests[name]['files'][file_name];
  await fs.remove(path);

  currentOpenedFile.value = null;
}

/**
 * Creates a new IO file and attaches it to the test
 * @param test test object
 * @param shown_name name of file showed to user (e.g. file1)
 * @param file_name name of file in FS (e.g. test0.file_in.file1)
 */
async function add_file_to_test(test: Test, shown_name: string, file_name: string): Promise<void> {
  test['files'][shown_name] = '/' + file_name;
  await fs.open(file_name, { hide_tab: true });
}

interface YamlTestRecord {
  name: string;
  title?: string;
  args?: string[];
  exit_code?: number;
}

/**
 * Load all tests from 'tests.yml' file and all associated IO files
 */
async function load() {
  let new_tests: Record<string, Test> = {};

  if (await fs.open('tests.yml', { hide_tab: true })) {
    const descs: YamlTestRecord[] = yaml.load(openedFiles.value['/tests.yml'].content);

    if (Array.isArray(descs)) {
      for (const test of descs) {
        if (test.name) {
          new_tests[test.name] = new_tests[test.name] || create(test.name);
          if (test.args) {
            new_tests[test.name].args = test.args.join(' ');
          }
          new_tests[test.name].title = test.title;
          new_tests[test.name].exit_code = test.exit_code;
        }
      }
    }
  }

  for (const inode of cwd.value) {
    if (inode.type != 'file') {
      continue;
    }

    const parts = inode.name.split('.');
    const ext = parts[parts.length - 1];
    const name = parts[0];
    if (ext == 'out' || ext == 'in' || (ext == 'err' && parts.length == 2)) {
      new_tests[name] = new_tests[name] || create(name);
      await add_file_to_test(new_tests[name], 'std' + parts[1], inode.name);
    } else if (parts.length >= 3) {
      const dir = parts[1];
      if (dir == 'file_in' || dir == 'file_out') {
        new_tests[name] = new_tests[name] || create(name);
        await add_file_to_test(new_tests[name], parts.slice(2).join('.'), inode.name);
      }
    }
  }

  Object.assign(tests, new_tests);
  loaded.value = true;
}

watch(
  tests,
  () => {
    if (loaded.value) save(tests);
  },
  { deep: true }
);

async function save(tests: Record<string, Test>) {
  let description: Array<YamlTestRecord> = [];
  for (const [name, test] of Object.entries(tests)) {
    let data: YamlTestRecord = { name: name };
    if (test.args) {
      data.args = test.args.split(' ');
    }

    if (test.title) {
      data.title = test.title;
    }

    if (test.exit_code) {
      data.exit_code = test.exit_code;
    }

    if (data) {
      description.push(data);
    }
  }

  if (!(await fs.open('tests.yml', { hide_tab: true }))) {
    await fs.createFile('tests.yml');
    await fs.open('tests.yml', { hide_tab: true });
  }
  openedFiles.value['/tests.yml'].content = yaml.dump(description);
}

function file_sorter(a: [string, string], b: [string, string]): number {
  const stds = ['stdin', 'stdout', 'stderr'];
  const isStd = (name: string) => stds.indexOf(name) != -1;

  let a_key: string = a[0];
  let b_key: string = b[0];

  if (isStd(a_key) && isStd(b_key)) {
    return stds.indexOf(a_key) < stds.indexOf(b_key) ? -1 : 1;
  }

  if (isStd(a_key)) {
    return -1;
  }

  return 1;
}

load();
</script>

<template>
  <div v-if="loaded" class="tests ps-3">
    <div v-for="(test, name) in tests" :key="name">
      <h2>
        {{ test.name }}

        <span v-for="fd in ['stdin', 'stdout', 'stderr']" :key="fd">
          <button
            v-if="!test.files[fd]"
            class="btn btn-sm btn-success me-1"
            @click="add_file(test.name, fd, fd.replace('std', ''))"
          >
            <span class="iconify" data-icon="ant-design:plus-outlined"></span>
            {{ fd }}
          </button>
        </span>

        <div class="btn-group" role="group" aria-label="Basic example">
          <input
            type="text"
            v-model="new_test_io_file[name]"
            class="form-control form-control-sm"
            placeholder="Filename"
          />

          <button
            type="button"
            class="btn btn-sm btn-success text-nowrap"
            @click="
              () => {
                if (new_test_io_file)
                  add_file(test.name, new_test_io_file[name], `file_in.${new_test_io_file[name]}`);
              }
            "
          >
            <span class="iconify" data-icon="ant-design:plus-outlined"></span>input
          </button>
          <button
            type="button"
            class="btn btn-sm btn-success text-nowrap"
            @click="
              () => {
                if (new_test_io_file[name])
                  add_file(
                    test.name,
                    new_test_io_file[name],
                    `file_out.${new_test_io_file[name]}}`
                  );
              }
            "
          >
            <span class="iconify" data-icon="ant-design:plus-outlined"></span>output
          </button>
        </div>
        &nbsp;
        <button class="btn btn-sm btn-danger" @click="delete_test(test.name)">
          <span class="iconify" data-icon="humbleicons:times"></span>
        </button>
      </h2>

      <div class="row mb-0">
        <label class="col-sm-2 col-form-label" for="title">Title</label>
        <input
          v-model="test.title"
          name="title"
          type="text"
          class="form-control form-control-sm col-sm-10"
        />
      </div>

      <div class="row mb-0">
        <label class="col-sm-2 col-form-label" for="args">Program Arguments</label>
        <input
          v-model="test.args"
          name="args"
          type="text"
          class="form-control form-control-sm col-sm-10"
        />
      </div>

      <div class="row mb-0">
        <label class="col-sm-2 col-form-label" for="exit-code">Exit code</label>
        <input
          v-model="test.exit_code"
          name="exit-code"
          type="number"
          class="form-control form-control-sm col-sm-10"
          placeholder="Default 0"
        />
      </div>

      <div v-for="[k, v] in Object.entries(test.files).sort(file_sorter)" :key="k">
        <h3>
          {{ k }}
          <button class="btn btn-sm btn-danger" @click="remove_file(test.name, k)">
            <span class="iconify" data-icon="humbleicons:times"></span>
          </button>
        </h3>
        <Editor v-model="openedFiles[v].content" />
      </div>

      <hr />
    </div>
    <button class="btn btn-success" @click="add_test()">
      <span class="iconify" data-icon="ant-design:plus-outlined"></span>
      Add new test
    </button>
  </div>
  <div v-else class="d-flex justify-content-center">
    <SyncLoader />
  </div>
</template>

<style scoped>
:global(.tests .CodeMirror) {
  height: 200px !important;
  min-height: 200px !important;
}
</style>
